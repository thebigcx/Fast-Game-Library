#include <renderer/EnvironmentMap.h>
#include <renderer/Texture2D.h>
#include <util/Image.h>
#include <renderer/Framebuffer.h>
#include <renderer/MeshFactory.h>
#include <renderer/RenderCommand.h>

namespace Engine
{

EnvironmentMap::EnvironmentMap(const std::string& hdrFile)
{
    this->initialise();

    m_envMap = EnvironmentMap::hdrToCubemap(hdrFile);
    m_irradianceMap = EnvironmentMap::createIrradianceMap(m_envMap);
    m_prefilterMap = EnvironmentMap::createPrefilterMap(m_envMap, m_irradianceMap);
    m_brdfLUT = EnvironmentMap::createBRDFLUT();
}

Reference<EnvironmentMap> EnvironmentMap::create(const std::string& file)
{
    auto map = createReference<EnvironmentMap>(file);
    return map;
}

/**
 * Converts a .hdr file into a TextureCube
 * @param hdrFile The .hdr file to convert
 * @return TextureCube converted from hdr
 */
Reference<TextureCube> EnvironmentMap::hdrToCubemap(const std::string& hdrFile)
{
    Reference<TextureCube> cubemap;

    Reference<Image> image = Image::create(hdrFile, true);

    Reference<Texture2D> hdrTexture = Texture2D::create(image->getWidth(), image->getHeight(), SizedTextureFormat::RGB16F, true, true);
    hdrTexture->setData(0, 0, image->getWidth(), image->getHeight(), image->getData(), TextureFormat::RGB, DataType::Float);

    cubemap = TextureCube::create(512, 512, SizedTextureFormat::RGB16F, true, true);

    if (!s_cubeMesh)
    {
        s_cubeMesh = MeshFactory::cubeMesh(2.f);
    }

    Reference<Framebuffer> framebuffer = Framebuffer::create();
    framebuffer->bind();
    RenderCommand::setViewport(0, 0, 512, 512);
    Reference<Renderbuffer> renderbuffer = Renderbuffer::create(512, 512, GL_DEPTH_COMPONENT24);
    framebuffer->attachRenderbuffer(*renderbuffer, Framebuffer::Attachment::Depth);
    // TODO: platform independent and refactor

    s_convertShader->bind();
    s_convertShader->setMatrix4("uProjection", s_captureProjection);

    hdrTexture->bind(0);
    framebuffer->bind();

    for (uint32_t i = 0; i < 6; i++)
    {
        s_convertShader->setMatrix4("uView", s_captureViews[i]);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, cubemap->getId(), 0); // TODO: IMPORTANT! make platform independent

        s_cubeMesh->vertexArray->bind();
        RenderCommand::clear(RenderCommand::defaultClearBits());
        RenderCommand::renderIndexed(s_cubeMesh->vertexArray);
    }

    framebuffer->unbind();

    cubemap->bind();// TODO: platform independent    
    glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

    return cubemap;
}

/**
 * Creates the irradiance map of the environment.
 * @param envMap The environment map
 * @returns Environment irradiance map
 */
Reference<TextureCube> EnvironmentMap::createIrradianceMap(const Reference<TextureCube>& envMap)
{
    Reference<TextureCube> irradianceMap;

    irradianceMap = TextureCube::create(32, 32, SizedTextureFormat::RGB16F, true, true);

    Reference<Framebuffer> framebuffer = Framebuffer::create();
    framebuffer->bind();
    Reference<Renderbuffer> renderbuffer = Renderbuffer::create(32, 32, GL_DEPTH_COMPONENT24);
    framebuffer->attachRenderbuffer(*renderbuffer, Framebuffer::Attachment::Depth);
    RenderCommand::setViewport(0, 0, 32, 32);

    s_irradianceShader->bind();
    s_irradianceShader->setMatrix4("uProjection", s_captureProjection);
    envMap->bind(0);

    framebuffer->bind();
    for (uint32_t i = 0; i < 6; i++) // ++i?
    {
        s_irradianceShader->setMatrix4("uView", s_captureViews[i]);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, irradianceMap->getId(), 0); // TODO: IMPORTANT! make platform independent

        s_cubeMesh->vertexArray->bind();
        RenderCommand::clear(RenderCommand::defaultClearBits());
        RenderCommand::renderIndexed(s_cubeMesh->vertexArray);
    }

    framebuffer->unbind();

    return irradianceMap;
}

/**
 * Prefilters the environment for roughness calculations.
 * @param envMap The environment cubemap
 * @param irradianceMap The irradiance cubemap generated by createIrradianceMap()
 * @returns The prefilter environment map
 */
Reference<TextureCube> EnvironmentMap::createPrefilterMap(const Reference<TextureCube>& envMap, const Reference<TextureCube>& irradianceMap)
{
    Reference<TextureCube> prefilterMap;

    prefilterMap = TextureCube::create(128, 128, SizedTextureFormat::RGB16F, true, true, true);

    if (!s_prefilterShader)
        s_prefilterShader = Shader::createFromFile("Engine/assets/shaders/EngineIBL_Prefilter.glsl");

    s_prefilterShader->bind();
    s_prefilterShader->setMatrix4("uProjection", s_captureProjection);

    envMap->bind(0);

    Reference<Framebuffer> framebuffer = Framebuffer::create();
    framebuffer->bind();

    unsigned int mipmapLevels = 5;
    for (unsigned int mip = 0; mip < mipmapLevels; mip++)
    {
        unsigned int mipWidth = 128 * std::pow(0.5, mip);
        unsigned int mipHeight = 128 * std::pow(0.5, mip);

        Reference<Renderbuffer> renderbuffer = Renderbuffer::create(mipWidth, mipHeight, GL_DEPTH_COMPONENT24);
        RenderCommand::setViewport(0, 0, mipWidth, mipHeight);

        float roughness = (float)mip / (float)(mipmapLevels - 1);
        s_prefilterShader->setFloat("uRoughness", roughness);

        for (unsigned int i = 0; i < 6; ++i)
        {
            s_prefilterShader->setMatrix4("uView", s_captureViews[i]);
            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, prefilterMap->getId(), mip);

            s_cubeMesh->vertexArray->bind();
            RenderCommand::clear(RenderCommand::defaultClearBits());
            RenderCommand::renderIndexed(s_cubeMesh->vertexArray);
        }
    }

    framebuffer->unbind();

    return prefilterMap;
}

/**
 * Creates the specular BRDF look-up texture (LUT).
 * @returns The specular BRDF LUT.
 */
Reference<Texture2D> EnvironmentMap::createBRDFLUT()
{
    Reference<Texture2D> brdfLUT;

    if (!s_brdfShader)
        s_brdfShader = Shader::createFromFile("Engine/assets/shaders/EngineIBL_BRDF.glsl");

    brdfLUT = Texture2D::create(512, 512, SizedTextureFormat::RGB16F, true, true);
    brdfLUT->bind();

    Reference<Framebuffer> framebuffer = Framebuffer::create();
    framebuffer->bind();
    Reference<Renderbuffer> renderbuffer = Renderbuffer::create(512, 512, GL_DEPTH_COMPONENT24);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, brdfLUT->getId(), 0);

    RenderCommand::setViewport(0, 0, 512, 512);
    s_brdfShader->bind();
    RenderCommand::clear(RenderCommand::defaultClearBits());
    auto mesh = MeshFactory::quadMesh(-1.f, -1.f, 1.f, 1.f);
    RenderCommand::renderIndexed(mesh->vertexArray);

    framebuffer->unbind();

    return brdfLUT;
}

void EnvironmentMap::initialise()
{
    if (!s_convertShader)
        s_convertShader = Shader::createFromFile("Engine/assets/shaders/EngineIBL_EquirectangularToCubemap.glsl");

    if (!s_irradianceShader)
        s_irradianceShader = Shader::createFromFile("Engine/assets/shaders/EngineIBL_Irradiance.glsl");

    s_captureProjection = math::perspective((float)math::radians(90.f), 1.f, 0.1f, 10.f);
    s_captureViews =
    {
        math::lookAt(math::vec3(0.f), math::vec3( 1.f,  0.f,  0.f), math::vec3(0.f, -1.f,  0.f)),
        math::lookAt(math::vec3(0.f), math::vec3(-1.f,  0.f,  0.f), math::vec3(0.f, -1.f,  0.f)),
        math::lookAt(math::vec3(0.f), math::vec3( 0.f,  1.f,  0.f), math::vec3(0.f,  0.f,  1.f)),
        math::lookAt(math::vec3(0.f), math::vec3( 0.f, -1.f,  0.f), math::vec3(0.f,  0.f, -1.f)),
        math::lookAt(math::vec3(0.f), math::vec3( 0.f,  0.f,  1.f), math::vec3(0.f, -1.f,  0.f)),
        math::lookAt(math::vec3(0.f), math::vec3( 0.f,  0.f, -1.f), math::vec3(0.f, -1.f,  0.f))
    };
}

}